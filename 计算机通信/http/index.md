#### HTTP是什么
> HTTP（Hyper Text Transition Protocol）超文本传输协议是TCP/IP协议族中的一个数据交互协议，位于应用层，现代浏览器数据交互都是通过此协议

#### HTTP协议由那几部分构成
一条完整的HTTP请求由两部分组成，分为`请求报文`和`响应报文`

1. 请求报文
- 请求行
  请求行分为`请求方法`、`请求路径`和`HTTP协议版本`
  ```
    POST /data http/1.1
  ```
- 请求头
- 请求体
2. 响应报文
- 状态行
- 响应头
- 响应体

#### HTTP有哪些请求方法
- GET：用来获取资源
- POST：上传数据
- DELETE：用于删除某些数据
- PUT：修改数据
- OPTIONS：当出现跨域请求时浏览器自动发起的

**GET和POST的区别**

- GET请求的数据会在浏览器的历史记录中存下来，而POST不会
- 在不同浏览器下，GET请求的长度是有限的
- GET请求传输的参数是明文的，而POST一般不会被不使用开发者工具的情况下相对而言保密性更高

**什么是简单请求与复杂请求**
`OPTIONS`请求是在跨域时浏览器向目标服务器主动发出的一个预检请求，目的是为了确认我们发出的那个真正请求是否可以被响应。复杂请求和简单请求区别就在于是否发出了`OPTIONS`请求

**简单请求**
- 请求方法是GET、POST、HEAD的请求
- 人为设置了规范集合之内的首部字段，如`Accept`、`Accept-Language`、`Content-Language`、`Content-Type`
- Content-Type 的值仅限于下列三者之一，即`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

**复杂请求**
- 使用了下面任一请求方法，PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH
- 人为设置简单请求外的字段
- Content-Type 的值不属于下列之一，application/x-www-form-urlencoded、multipart/form-data、text/plain

#### HTTP有哪些状态码
RFC 规定 HTTP 的状态码为「三位数」，第一个数字定义了响应的类别，被分为五类:

- 「1xx」: 代表请求已被接受，需要继续处理。
- 「2xx」: 表示成功状态。
- 「3xx」: 重定向状态。
- 「4xx」: 客户端错误。
- 「5xx」: 服务器端错误。

**1xx信息类状态码**
接受的请求正在处理，信息类状态码。

**2xx请求成功**
- 200 OK 请求被成功处理且正常响应
- 204 请求成功，但没有资源可返回

**3xx重定向**
- 301 永久重定向
- 302 临时重定向
- 303 表示资源存在着另一个URL，应使用GET方法获取资源。
- 304 当协商缓存命中时会返回这个状态码。
- 307 临时重定向，和302含义相同,不会改变method

**4xx客户端错误**
- 400 请求报文存在语法错误
- 401 表示发送的请求需要有通过 HTTP 认证的认证信息。
- 402 表示对请求资源的访问被服务器拒绝
- 404 服务器上没有相应资源
- 405 服务器禁止使用该方法，客户端可通过options方法来查看服务器允许的访问方法，如下
  ```
  Access-Control-Allow-Methods →GET,HEAD,PUT,PATCH,POST,DELETE
  ```

**5xx服务端错误**
- 500 服务器在执行相关请求时发生了错误
- 502 服务器自身是正常的，访问的时候出了问题
- 503 服务器暂时处于超负载或正在停机维护，无法处理请求。

#### HTTP的优缺点
**HTTP优点**
1. 「灵活可扩展」。一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。
2. 「请求-应答模式」，通常而言，就是一方发送消息，另外一方要接受消息，或者是做出相应等。
3. 「可靠传输」，HTTP是基于TCP/IP，因此把这一特性继承了下来。
4. 「无状态」，在一次连接请求结束后，服务器并不认识下一次来请求资源的是谁

**HTTP缺点**
1. 「无状态」，有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等，另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说。
2. 「明文传输」，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。
3. 「队头阻塞」，当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。


#### HTTP缓存策略
**强缓存**
强缓存两个相关字段，「**Expires**」，「**Cache-Control**」。

「**强缓存分为两种情况，一种是发送HTTP请求，一种不需要发送。**」

首先检查强缓存，这个阶段不需要发送HTTP请求。通过查找不同的字段来进行，不同的HTTP版本所以不同。
- HTTP1.0版本，使用的是Expires，HTTP1.1使用的是Cache-Control

**Expires**
Expires即过期时间，时间是相对于服务器的时间而言的，存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。如下
```
 Cache-Control:max-age=6000
```
这个方式有一个问题：「**服务器的时间和浏览器的时间可能并不一致**」，所以HTTP1.1提出新的字段代替它。

**Cache-Control**
HTTP1.1版本中，使用的就是该字段，这个字段采用的时间是过期时长，对应的是max-age。
```
Cache-Control:max-age=6000
```
上面代表该资源返回后6000秒，可以直接使用缓存。
注意点：

- 当Expires和Cache-Control同时存在时，优先考虑Cache-Control。
- 当然了，当缓存资源失效了，也就是没有命中强缓存，接下来就进入协商缓存👇

**协商缓存**

强缓存失效后，浏览器在请求头中携带响应的`缓存Tag`来向服务器发送请求，服务器根据对应的tag，来决定是否使用缓存。

缓存分为两种，「**Last-Modified**」 和 「**ETag**」。两者各有优势，并不存在谁对谁有`绝对的优势`，与上面所讲的强缓存两个Tag所不同。

这个字段表示的是「**最后修改时间**」。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。

浏览器接收到后，「**如果再次请求**」，会在请求头中携带`If-Modified-Since`字段，这个字段的值也就是服务器传来的最后修改时间。

服务器拿到请求头中的`If-Modified-Since`的字段后，其实会和这个服务器中`该资源的最后修改时间`对比:

- 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。

- 否则返回304，告诉浏览器直接使用缓存。

**ETag**

ETag是服务器根据当前文件的内容，对文件生成唯一的标识，比如MD5算法，只要里面的内容有改动，这个值就会修改，服务器通过把响应头把该字段给浏览器。

浏览器接受到ETag值，会在下次请求的时候，将这个值作为「**If-None-Match**」这个字段的内容，发给服务器。

服务器接收到「**If-None-Match**」后，会跟服务器上该资源的「**ETag**」进行比对👇

- 如果两者一样的话，直接返回304，告诉浏览器直接使用缓存
- 如果不一样的话，说明内容更新了，返回新的资源，跟常规的HTTP请求响应的流程一样

**两者对比**

- 性能上，Last-Modified优于ETag，Last-Modified记录的是时间点，而Etag需要根据文件的MD5算法生成对应的hash值。
- 精度上，ETag优于Last-Modified。ETag按照内容给资源带上标识，能准确感知资源变化，Last-Modified在某些场景并不能准确感知变化，比如👇
  - 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
  - Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。

最后，「**如果两种方式都支持的话，服务器会优先考虑**`ETag`」。

#### HTTP和HTTPS的区别
HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 SSL/TLS 所做的工作。

那么区别有哪些呢👇

- HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。
- HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页。
- HTTPS标准端口443，HTTP标准端口80。
- HTTPS需要用到SSL证书，而HTTP不用。

